clc
close all
pst=curve{1};
C=pst';
n=size(C,1);  %n--the num of points 
D=zeros(n,n); %D--initialize the distance matrix
for i=1:n
   for j=1:n
       if i~=j
           D(i,j)=((C(i,1)-C(j,1))^2+(C(i,2)-C(j,2))^2+(C(i,3)-C(j,3))^2)^0.5; %Caculate the distance betwwen two points
       else
           D(i,j)=0;   %i=j, distance=0；
       end
   end
end
 %%==================The process of ACA======================================================
 %%============== 第一步 Initialize the PARAs in ACA==============
iter_max=200;   % Maximum Iterrations
m=60;           % The number of ants
Alpha=1;        % Parameters characterizing the importance of pheromones
Beta=5;         % Parameters characterizing the importance of heuristic factors
Rho=0.7;        % Pheromone evaporation factor
Q=20;           % Pheromone increase intensity factor
Eta=1./D;          % Eta is the visibility factor, set here as the reciprocal of the distance
Tau=ones(n,n);     % Tau is the pheromone matrix, initialized to 1
Tabu=zeros(m,n);   % Save and record the generation of paths
nC=1;              % Iteration Counter
R_best=zeros(iter_max,n);   %The shortest route for each generation, the maximum number of iterations of the behavior, and the number of points
L_best=inf.*ones(iter_max,1);%%The length of the shortest route for each generation, inf is infinite
L_ave=zeros(iter_max,1);     % Average route length by generation
 
 %%============== STEP 2 Place m ants on the city==============
while nC<=iter_max    %One of the stopping conditions: reaching the maximum number of iterations 
    Randpos=[];
    for i=1:(ceil(m/n))       %ceil表示向无穷方向取整
        Randpos=[Randpos,randperm(n)]; %randperm(n)：表示随机产生一个整数排列
    end
 Tabu(:,1)=(Randpos(1,1:m))'; %每只蚂蚁（m只）都对应有一个位置，Tabu(:,1)为每只蚂蚁走过的第一个城市
  
%% ============== 第三步 m只蚂蚁按概率函数选择下一座城市，完成各自的周游==============
  for j=2:n       %城市从第二个开始
     for  i=1:m
        visited=Tabu(i,1:(j-1));      %已访问的城市
        J=zeros(1,(n-j+1));           %待访问的城市
        P=J;                          %待访问城市的选择概率分布（初始化）
        Jc=1;                         %循环下标
            
       for k=1:n     %利用循环求解待访问城市，如果第k个城市不属于已访问城市，则其为待访问城市
          if  length(find(visited==k))==0
            J(Jc)=k;
            Jc=Jc+1;   %下表加1，便于下一步存储待访问的城市
          end
       end
      
       for k=1:length(J)   % 下面计算待访问城市的概率分布，length(J)表示待访问城市个数
         P(k)=(Tau(visited(end),J(k))^Alpha)*(Eta(visited(end),J(k))^Beta); %概率计算公式中的分子
       end
         P=P/(sum(P));     %概率分布：长度为待访问城市个数
         Pcum=cumsum(P);   %求累积概率和：cumsum（[1 2 3])=1 3 6,目的在于使得Pcum的值总有大于rand的数
         Select=find(Pcum>=rand);  %按概率选取下一个城市：当累积概率和大于给定的随机数，则选择求和被加上的最后一个城市作为即将访问的城市
       if  isempty(Select)    %若选择城市为空集，则随机将任一城市加入禁忌表中
         Tabu(i,j)=round(1+(n-1)*rand);
       else
         next_visit=J(Select(1));   %next_visit表示即将访问的城市
         Tabu(i,j)=next_visit;      %将访问过的城市加入禁忌表中
       end
     end
  end
    
    if nC>=2;Tabu(1,:)=R_best(nC-1,:);end  %若迭代次数大于等于2，则将上一次迭代的最佳路线存入到Tabu的第一行中
 
%% ==============第四步 记录本次迭代最佳路线==============
 L=zeros(m,1);
  for i=1:m;
      R=Tabu(i,:);
    for j=1:(n-1)
      L(i)=L(i)+D(R(j),R(j+1));  %求路径距离
    end
      L(i)=L(i)+D(R(1),R(n));    %加上最后一个城市与第一个城市之间的距离
  end
  L_best(nC)=min(L);            %最优路径为距离最短的路径
  pos=find(L==L_best(nC));      %找出最优路径对应的位置：即为哪只蚂蚁
  R_best(nC,:)=Tabu(pos(1),:);  %确定最优路径对应的城市顺序
  L_ave(nC)=mean(L); 
% Shortest_Route=[Shortest_Route Shortest_Route(1)];
plot([C( R_best(nC,:),1)],[C( R_best(nC,:),2)],'o-');
drawnow
grid on

  
  
  %求第k次迭代的平均距离
  nC=nC+1;
   
%% ==============STEP5 Ant ==============
 Delta_Tau=zeros(n,n);  
   for i=1:m
      for j=1:(n-1)     
        Delta_Tau(Tabu(i,j),Tabu(i,j+1))=Delta_Tau(Tabu(i,j),Tabu(i,j+1))+Q/L(i);
      end
        Delta_Tau(Tabu(i,n),Tabu(i,1))=Delta_Tau(Tabu(i,n),Tabu(i,1))+Q/L(i);
   end
Tau=(1-Rho).*Tau+Delta_Tau;   
 
%% ==============STEP6 Tabu set to ZERO==============
Tabu=zeros(m,n);
end
 
%% ==============STEP7 Outputs==============
Pos=find(L_best==min(L_best));     %找到L_best中最小值所在的位置
Shortest_Route=R_best(Pos(1),:)   %提取最短路径
Shortest_Length=L_best(Pos(1))    %提取最短路径长度
 
%% ==============Iteration Figures==============
figure(1)   %Iterations
x=linspace(0,iter_max,iter_max);
y=L_best(:,1);
plot(x,y,'-','LineWidth',2);
xlabel('Iterations'); ylabel('Thelength of shortest path');
 bestPath=Shortest_Route;
figure(2)   %作最短路径图
plot3([C(Shortest_Route,1)],[C(Shortest_Route,2)],[C(Shortest_Route,3)],'o-');
axis equal
for i = 1:size(C,1)
    text(C(i,1),C(i,2),C(i,3),['   ' num2str(i)]);
end


N=length(curve);
for ii=1:N
    newCurve{ii}=curve{ii}(:,Shortest_Route);
end












